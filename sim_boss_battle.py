
import sys
import os
import random
import time

# Ensure dungeon package is in path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from dungeon import config
# config.LANGUAGE = "en"  # Uncomment for English logs

from dungeon.balance_simulator import HeadlessEngine, setup_player_for_test
from dungeon.components import PositionComponent, MonsterComponent

def run_boss_tests(iterations=10):
    scenarios = [
        {"boss": "BUTCHER",   "floor": 20, "level": 20},
        {"boss": "LEORIC",    "floor": 25, "level": 25},
        {"boss": "LICH_KING", "floor": 28, "level": 28},
        {"boss": "DIABLO",    "floor": 30, "level": 30}
    ]
    
    classes = ["WARRIOR", "ROGUE", "SORCERER", "BARBARIAN"]
    
    print(f"Starting Boss Battle Simulation ({iterations} iter/class)...")
    print("=" * 60)

    results = {}

    for scen in scenarios:
        boss_name = scen["boss"]
        floor = scen["floor"]
        level = scen["level"]
        
        print(f"\n[Scenario] {boss_name} (Floor {floor}, Lv {level})")
        results[boss_name] = {}
        
        for class_id in classes:
            stats = {"WIN": 0, "DEATH": 0, "TIMEOUT": 0, "ERROR": 0}
            total_turns = 0
            total_potions = 0
            
            # Progress bar visual
            sys.stdout.write(f"  {class_id:<10}: ")
            sys.stdout.flush()
            
            for i in range(iterations):
                engine = HeadlessEngine()
                engine.current_level = floor
                
                # 1. Initialize World
                engine._initialize_world()
                
                # 2. Force Map Type BOSS
                engine.dungeon_map.map_type = "BOSS"
                
                # 3. Clear existing monsters to ensure 1v1 (or Boss+Minions only)
                # (Optional, but good for clean testing of strictly Boss logic)
                # But Bosses spawn minions, so we keep engine logic if possible.
                # However, to be SAFE, we manually spawn the boss to ensure it exists.
                
                # Find valid spawn point (center room usually for Boss maps)
                # Boss maps usually have 1 big room.
                center_x = engine.dungeon_map.width // 2
                center_y = engine.dungeon_map.height // 2
                
                # Spawn Boss
                # Check if boss already exists (generated by default logic?)
                boss_exists = False
                for m_ent in engine.world.get_entities_with_components({MonsterComponent}):
                    m_comp = m_ent.get_component(MonsterComponent)
                    if m_comp.monster_id == boss_name:
                        boss_exists = True
                        break
                
                if not boss_exists:
                    # Manually spawn
                    boss_ent = engine._spawn_boss(center_x + 5, center_y, pool=[], boss_name=boss_name)
                    if not boss_ent:
                        # Should not happen if name is correct
                        print(f"FAILED TO SPAWN {boss_name}")
                        stats["ERROR"] += 1
                        continue
                
                # 4. Setup Player
                setup_player_for_test(engine, floor, level, class_id)
                
                # Move Player to near boss
                p_ent = engine.world.get_player_entity()
                p_pos = p_ent.get_component(PositionComponent)
                p_pos.x = center_x
                p_pos.y = center_y
                
                # Run
                outcome = engine.run()
                stats[outcome] += 1
                total_turns += engine.current_turns
                total_potions += engine.metrics.get("potions_used", 0)
                
                # Visual dot
                if outcome == "WIN": sys.stdout.write(".")
                elif outcome == "DEATH": sys.stdout.write("x")
                elif outcome == "TIMEOUT": sys.stdout.write("T")
                else: sys.stdout.write("?")
                sys.stdout.flush()
                
            win_rate = (stats["WIN"] / iterations) * 100
            avg_turns = total_turns / iterations
            avg_potions = total_potions / iterations
            
            print(f" [{win_rate:.0f}%] turns: {avg_turns:.1f}, pots: {avg_potions:.1f}")
            
            results[boss_name][class_id] = {
                "win": win_rate,
                "turns": avg_turns,
                "potions": avg_potions
            }
            
    print("\n" + "=" * 60)
    print("FINAL REPORT")
    print("=" * 60)
    for boss, c_data in results.items():
        print(f"[{boss}]")
        for cls, metrics in c_data.items():
            print(f"  {cls:<10}: Win {metrics['win']:3.0f}% | Turns {metrics['turns']:5.1f} | Pots {metrics['potions']:4.1f}")
            
if __name__ == "__main__":
    run_boss_tests()
